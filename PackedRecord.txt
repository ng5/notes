import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.*;

/**

PackedRecord (Java MVP)

Schema-driven contiguous layout with a fixed area + variable area (for strings/bytes).

Supports freeze() to return a tight, read-only view and unfreeze() to enable mutation/growth.

Design goals:

Contiguous, cache-friendly storage


Zero GC per field; only the backing buffer is an object


Schema computes fixed offsets; ref fields store (int offset, int length) into variable area


freeze() compacts to exact size; unfreeze() grows capacity


This MVP focuses on clarity and correctness with attention to alignment and deterministic little-endian layout. */ public final class PackedRecord { // ===== Types & Schema ===== public enum FieldType { I32, I64, F64, BOOL, STR, BYTES }

public static final class Field { public final String name; public final FieldType type; final int offset; // offset within fixed area Field(String name, FieldType type, int offset) { this.name = name; this.type = type; this.offset = offset; } @Override public String toString() { return name + ":" + type + "@" + offset; } }

public static final class Schema { private final List<Field> fields; private final Map<String, Field> byName; private final int fixedSize;

private Schema(List<Field> fs, int fixedSize) {
     this.fields = List.copyOf(fs);
     this.byName = new HashMap<>();
     for (Field f : fields) byName.put(f.name, f);
     this.fixedSize = fixedSize;
 }
 public int fixedSize() { return fixedSize; }
 public Field field(String name) { return Objects.requireNonNull(byName.get(name), "Unknown field: " + name); }
 public List<Field> fields() { return fields; }

 public static final class Builder {
     private final List<Map.Entry<String, FieldType>> defs = new ArrayList<>();
     /** Add a field in order. */
     public Builder add(String name, FieldType type) {
         defs.add(Map.entry(name, type));
         return this;
     }
     public Schema build() {
         int off = 0;
         List<Field> fs = new ArrayList<>(defs.size());
         for (var e : defs) {
             FieldType t = e.getValue();
             int sz = switch (t) {
                 case I32 -> 4;
                 case I64, F64 -> 8;
                 case BOOL -> 1; // stored as byte 0/1
                 case STR, BYTES -> 8; // two ints: (absolute offset, length)
             };
             int align = (sz >= 8) ? 8 : (sz >= 4 ? 4 : 1);
             off = align(off, align);
             fs.add(new Field(e.getKey(), t, off));
             off += sz;
         }
         off = align(off, 8); // keep var area 8-aligned
         return new Schema(fs, off);
     }
     private static int align(int x, int a) { int r = x % a; return r == 0 ? x : x + (a - r); }
 }

}

// ===== PackedRecord ===== private final Schema schema; private ByteBuffer buf;      // little-endian for deterministic layout private boolean frozen;      // if true: read-only buffer, tight length private final int varStart;  // absolute offset where variable area begins private int varEnd;          // absolute write cursor within buffer

private static final Charset UTF8 = StandardCharsets.UTF_8; private static final int NULL_LEN = -1; // indicates null ref for STR/BYTES

private PackedRecord(Schema schema, ByteBuffer backing, boolean frozen) { this.schema = schema; this.buf = backing.order(ByteOrder.LITTLE_ENDIAN); this.frozen = frozen; this.varStart = schema.fixedSize(); this.varEnd = Math.max(varStart, buf.limit()); if (this.varEnd < varStart) this.varEnd = varStart; }

/** Allocate a mutable record with space for variable data. */ public static PackedRecord allocate(Schema schema, int variableCapacityBytes) { int capacity = schema.fixedSize() + Math.max(align(variableCapacityBytes, 8), 0); ByteBuffer bb = ByteBuffer.allocateDirect(capacity).order(ByteOrder.LITTLE_ENDIAN); bb.limit(schema.fixedSize()); // initially only fixed area is meaningful PackedRecord pr = new PackedRecord(schema, bb, false); pr.varEnd = pr.varStart; return pr; }

/** Wrap an existing buffer (read-only). Expects tight (already frozen) layout. */ public static PackedRecord wrapFrozen(Schema schema, ByteBuffer readOnlyTight) { ByteBuffer ro = readOnlyTight.asReadOnlyBuffer().order(ByteOrder.LITTLE_ENDIAN); return new PackedRecord(schema, ro, true); }

public Schema schema() { return schema; } public boolean isFrozen() { return frozen; } public int byteSize() { return buf.limit(); } public ByteBuffer backingReadOnlySlice() { return buf.asReadOnlyBuffer(); }

// ===== Primitive accessors (by Field) ===== public void putInt(Field f, int v) { ensureMutable(); buf.putInt(f.offset, v); ensureFixedLimit(); } public int getInt(Field f) { return buf.getInt(f.offset); }

public void putLong(Field f, long v) { ensureMutable(); buf.putLong(f.offset, v); ensureFixedLimit(); } public long getLong(Field f) { return buf.getLong(f.offset); }

public void putDouble(Field f, double v) { ensureMutable(); buf.putDouble(f.offset, v); ensureFixedLimit(); } public double getDouble(Field f) { return buf.getDouble(f.offset); }

public void putBool(Field f, boolean v) { ensureMutable(); buf.put(f.offset, (byte)(v ? 1 : 0)); ensureFixedLimit(); } public boolean getBool(Field f) { return buf.get(f.offset) != 0; }

// ===== Ref fields: STR/BYTES use (int absOffset, int length) in fixed area ===== public void putString(Field f, String s) { Objects.requireNonNull(f); if (f.type != FieldType.STR) throw new IllegalArgumentException("Field is not STR: " + f); if (s == null) { writeRef(f, 0, NULL_LEN); return; } byte[] bytes = s.getBytes(UTF8); int off = appendVar(bytes); writeRef(f, off, bytes.length); } public String getString(Field f) { if (f.type != FieldType.STR) throw new IllegalArgumentException("Field is not STR: " + f); int off = buf.getInt(f.offset); int len = buf.getInt(f.offset + 4); if (len == NULL_LEN) return null; if (len == 0) return ""; ByteBuffer dup = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); int oldLim = dup.limit(); dup.position(off).limit(off + len); byte[] dst = new byte[len]; dup.get(dst); dup.limit(oldLim); return new String(dst, UTF8); }

public void putBytes(Field f, byte[] src) { Objects.requireNonNull(f); if (f.type != FieldType.BYTES) throw new IllegalArgumentException("Field is not BYTES: " + f); if (src == null) { writeRef(f, 0, NULL_LEN); return; } int off = appendVar(src); writeRef(f, off, src.length); } public byte[] getBytes(Field f) { if (f.type != FieldType.BYTES) throw new IllegalArgumentException("Field is not BYTES: " + f); int off = buf.getInt(f.offset); int len = buf.getInt(f.offset + 4); if (len == NULL_LEN) return null; byte[] dst = new byte[len]; ByteBuffer dup = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); int oldLim = dup.limit(); dup.position(off).limit(off + len); dup.get(dst); dup.limit(oldLim); return dst; }

/** Sets a ref field to null. */ public void putNull(Field f) { if (f.type != FieldType.STR && f.type != FieldType.BYTES) throw new IllegalArgumentException("Not a ref field: " + f); ensureMutable(); writeRef(f, 0, NULL_LEN); }

// ===== Freeze / Unfreeze ===== /** Compact to tight immutable buffer. Offsets remain valid because var area starts at same position. */ public void freeze() { if (frozen) return; int used = varEnd; // everything from 0..varEnd is meaningful ByteBuffer tight = ByteBuffer.allocateDirect(used).order(ByteOrder.LITTLE_ENDIAN); ByteBuffer src = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); src.clear(); // position=0, limit=capacity src.limit(used); tight.put(src); tight.flip(); tight.limit(used); buf = tight.asReadOnlyBuffer(); frozen = true; }

/** Make the record mutable with at least extra variable capacity beyond current usage. */ public void unfreeze(int extraVariableCapacityBytes) { int neededVarCap = Math.max(align(extraVariableCapacityBytes, 8), 0); int currentUsed = Math.max(varEnd, buf.limit()); int newCap = currentUsed + neededVarCap; ByteBuffer grow = ByteBuffer.allocateDirect(newCap).order(ByteOrder.LITTLE_ENDIAN); ByteBuffer src = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); src.clear(); src.limit(currentUsed); grow.put(src); grow.flip(); grow.limit(currentUsed); buf = grow; frozen = false; // varEnd remains as previously used end }

// ===== Utilities ===== private void ensureMutable() { if (frozen) throw new IllegalStateException("Record is frozen"); } private void ensureFixedLimit() { if (buf.limit() < varStart) buf.limit(varStart); }

private int appendVar(byte[] bytes) { ensureMutable(); int needed = align(bytes.length, 1); // byte alignment is fine; overall var area is already 8-aligned ensureCapacityForVar(needed); int off = varEnd; ByteBuffer dup = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); dup.position(off); dup.put(bytes); varEnd += needed; buf.limit(varEnd); return off; }

private void writeRef(Field f, int absoluteOffset, int len) { ensureMutable(); if (f.type != FieldType.STR && f.type != FieldType.BYTES) throw new IllegalArgumentException("Not a ref field: " + f); buf.putInt(f.offset, absoluteOffset); buf.putInt(f.offset + 4, len); ensureFixedLimit(); }

private void ensureCapacityForVar(int more) { int need = varEnd + more; if (need <= buf.capacity()) return; // Grow: 1.5x strategy int newCap = Math.max(need, (int)Math.min((long)buf.capacity() + (buf.capacity() >>> 1), Integer.MAX_VALUE)); ByteBuffer grow = ByteBuffer.allocateDirect(newCap).order(ByteOrder.LITTLE_ENDIAN); ByteBuffer src = buf.duplicate().order(ByteOrder.LITTLE_ENDIAN); src.clear(); int limit = Math.max(varEnd, buf.limit()); src.limit(limit); grow.put(src); grow.flip(); grow.limit(limit); buf = grow; }

private static int align(int x, int a) { int r = x % a; return r == 0 ? x : x + (a - r); }

private static boolean isAscii(ByteBuffer b, int off, int len) { ByteBuffer dup = b.duplicate(); for (int i = 0; i < len; i++) { int v = dup.get(off + i) & 0xFF; if (v > 0x7F) return false; } return true; }

/** Read-only UTF-8 view. Decodes lazily on demand and caches the resulting String. */ public static final class Utf8Slice implements CharSequence { private final ByteBuffer buf; private final int off; private final int len; private String cached; // filled on first char/length/toString access Utf8Slice(ByteBuffer buf, int off, int len) { this.buf = buf.asReadOnlyBuffer(); this.off = off; this.len = len; } private String materialize() { if (cached != null) return cached; ByteBuffer d = buf.duplicate(); int oldLimit = d.limit(); d.position(off).limit(off + len); cached = UTF8.decode(d).toString(); d.limit(oldLimit); return cached; } @Override public int length() { return materialize().length(); } @Override public char charAt(int index) { return materialize().charAt(index); } @Override public CharSequence subSequence(int start, int end) { return materialize().subSequence(start, end); } @Override public String toString() { return materialize(); } }

/** True zero-copy ASCII view (each byte maps to one char). Returns undefined for non-ASCII data. */ public static final class AsciiSlice implements CharSequence { private final ByteBuffer buf; private final int off; private final int len; AsciiSlice(ByteBuffer buf, int off, int len) { this.buf = buf.asReadOnlyBuffer(); this.off = off; this.len = len; } @Override public int length() { return len; } @Override public char charAt(int index) { return (char)(buf.get(off + index) & 0xFF); } @Override public CharSequence subSequence(int start, int end) { if (start < 0 || end < start || end > len) throw new IndexOutOfBoundsException(); return new AsciiSlice(buf, off + start, end - start); } @Override public String toString() { ByteBuffer d = buf.duplicate(); int oldLimit = d.limit(); d.position(off).limit(off + len); byte[] dst = new byte[len]; d.get(dst); d.limit(oldLimit); return new String(dst, StandardCharsets.ISO_8859_1); } } $1 public Field f(String name) { return schema.field(name); } public void putInt(String name, int v) { putInt(f(name), v); } public int getInt(String name) { return getInt(f(name)); } public void putLong(String name, long v) { putLong(f(name), v); } public long getLong(String name) { return getLong(f(name)); } public void putDouble(String name, double v) { putDouble(f(name), v); } public double getDouble(String name) { return getDouble(f(name)); } public void putBool(String name, boolean v) { putBool(f(name), v); } public boolean getBool(String name) { return getBool(f(name)); } public void putString(String name, String v) { putString(f(name), v); } public String getString(String name) { return getString(f(name)); } public void putBytes(String name, byte[] v) { putBytes(f(name), v); } public byte[] getBytes(String name) { return getBytes(f(name)); }

// ===== Debug / Introspection ===== @Override public String toString() { StringBuilder sb = new StringBuilder("PackedRecord{" + (frozen ? "frozen" : "mutable") + ", size=" + byteSize() + "}"); sb.append('\n').append("Fixed[" + schema.fixedSize() + "] fields:"); for (Field fd : schema.fields()) { sb.append('\n').append("  ").append(fd.name).append(": "); switch (fd.type) { case I32 -> sb.append(getInt(fd)); case I64 -> sb.append(getLong(fd)); case F64 -> sb.append(getDouble(fd)); case BOOL -> sb.append(getBool(fd)); case STR -> sb.append(Objects.toString(getString(fd))); case BYTES -> { byte[] b = getBytes(fd); sb.append(b == null ? "null" : ("bytes[" + b.length + "]")); } } } return sb.toString(); }

// ===== Example usage ===== public static void main(String[] args) { Schema schema = new Schema.Builder() .add("id", FieldType.I64) .add("name", FieldType.STR) .add("active", FieldType.BOOL) .add("score", FieldType.F64) .add("blob", FieldType.BYTES) .build();

PackedRecord rec = PackedRecord.allocate(schema, 128);
 rec.putLong("id", 42L);
 rec.putString("name", "Juno");
 rec.putBool("active", true);
 rec.putDouble("score", 98.75);
 rec.putBytes("blob", new byte[]{1,2,3,4,5});

 System.out.println("Before freeze:\n" + rec);
 rec.freeze();
 System.out.println("After freeze (tight size=" + rec.byteSize() + ")\n" + rec);

 // Unfreeze to append larger data
 rec.unfreeze(256);
 rec.putString("name", "Juno — blazing fast");
 rec.putBytes("blob", new byte[64]);
 System.out.println("After unfreeze & updates:\n" + rec);

} }


